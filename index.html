<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
              <section data-markdown><script type="text/template">
# What is Solr? 

*Traditionally:*

A search engine with support for text analysis, faceting, integrated spell-checker
              </script></section>
              <section data-markdown><script type="text/template">
# What is Solr?

*More recently:*

A scalable NoSQL database with support for full text search



              </script></section>
              <section data-markdown><script type="text/template">
# Part 1:
## Solr the search engine

              </script></section>
              <section data-markdown><script type="text/template">

## Powered by Lucene

Low level library for creating, accessing and managing indexes


              </script></section>
              <section data-markdown><script type="text/template">

## Powered by Lucene

Lucene is **mature**, used by *many* search-related libraries:

* Compass
* elasticsearch
* Amazon CloudSearch
* Hibernate Search
* ...

              </script></section>
              <section data-markdown><script type="text/template">

## Powered by Lucene

Sharing the same core team, Solr is always kept in-sync with the latest version of Lucene.

*(does not always happen with the other projects)*

              </script></section>
              <section data-markdown><script type="text/template">
## How indexing works
* documents  have multiple fields
* each field can be single or multi-valued.
* each value of a field is analyzed, tokenized and filtered according to **some rules*

              </script></section>
              <section data-markdown><script type="text/template">
## How indexing works

The result of the analysis is a list of tokens used as keys in the index.


              </script></section>
              <section data-markdown><script type="text/template">
## How indexing works

An index is basically a map between (field, token) and the list of documents matching that token in that field.


              </script></section>
              <section data-markdown><script type="text/template">
## How indexing works
E.g. for the documents
```
john = {name: "John", hobbies: "cycling, gaming, snooker" }
mary = {name: "Mary", hobbies: "reading, cycling" }
```
The index will look something like this:
```
"name:john" => [john]
"name:mary" => [mary]
"hobbies:cycling" => [john, mary]
"hobbies:gaming" => [john]
"hobbies:snooker" => [john]
"hobbies:reading" => [mary]
```

              </script></section>
              <section data-markdown><script type="text/template">
## How indexing works

This is called an inverted index

instead of
```
document -> token
```
the mapping is
```
token -> [document]
```

              </script></section>
              <section data-markdown><script type="text/template">
## Index schema

Getting back to the "some rules" part earlier:

> "each value of a field is analyzed, filtered and tokenized according to **some rules**"

              </script></section>
              <section data-markdown><script type="text/template">
## Index schema

Each field has a certain fieldType, which dictates how it should be analyzed and indexed. 

The *Schema* is simply the total set of rules for all fields.

              </script></section>
              <section data-markdown><script type="text/template">
## Index schema

Built-in field types:

- int/float/long/double: as expected
- tint/float/long/double: faster range queries at the expense of index size
- string: unprocessed strings

              </script></section>
              <section data-markdown><script type="text/template">
## Index schema
Built-in field types:

- text_general: generic cross-language default tokenization, case insensitive, removing stop words and applying synonims
- text_en
- text_en_splitting
- text_en_splitting_tight
- ....

              </script></section>
              <section data-markdown><script type="text/template">
## Index schema
The analysis process is extremely configurable:

- tens of tokenizers
- tens of filters: stopwords, synonyms
- can apply at query time or index time
- easily extensible with Java
<br />
Can *easily* become very complicated.

              </script></section>
              <section data-markdown><script type="text/template">
## Index schema

Other very important stuff:

* stored = true/false: whether to store the original value of a field after indexing. 
 * can impact performance by increasing the size of the index
* copyField: useful for analyzing a field two different ways.
* dynamicField: useful for creating "catch-all" fields, or for cases when our documents have a variable structure

              </script></section>
              <section data-markdown><script type="text/template">
## Index schema

From 4.4, Solr can work in schemaless mode. Field types are inferred from the JSON type.

For a high-performance search engine, this is unrecommended, but may be useful for a NoSQL database.

              </script></section>
              <section data-markdown><script type="text/template">
## Index schema
Getting a schema right is hard. 

Getting it right **the first time** is impossible.

              </script></section>
              <section data-markdown><script type="text/template">
## Index schema
The more features and/or performance you want, the more you'll need to learn to tweak the schema.

              </script></section>
              <section data-markdown><script type="text/template">
## Querying

At the basic level, a query is composed of:

- multiple expressions of the form field:value
- tied together with logical operators

              </script></section>
              <section data-markdown><script type="text/template">
## Querying

E.g:

- name:John AND hobbies:cycling
- hobbies:(cycling AND gaming) AND name:Mary
- hobbies:(cycling gaming) <- implied default operator OR, but is configurable

              </script></section>
              <section data-markdown><script type="text/template">

## Faceted search

Grouping the matching documents into "buckets" and counting how many of them there are in each bucket.

E.g given a query for books publisher:BestPublisher, faceting by "genre" may result in:

- Fiction (45)
- Biographies (30)
- History (10)


              </script></section>
              <section data-markdown><script type="text/template">
## Faceted search
Can arbitrarily facet by query, useful for counting documents in certain ranges, e.g. age intervals:

- under 18: 44
- 19-35: 80
- over 35: 10

              </script></section>
              <section data-markdown><script type="text/template">
## Faceted search

Supports counting only values with a certain prefix, useful when fields contain breadcrumbs.

E.g. facet.prefix=europe/romania:

- europe/romania/bucharest: 1942
- europe/romania/iasi: 432
- ...
  
              </script></section>
              <section data-markdown><script type="text/template">
## Faceted search

Also supports pivot facets, a.k.a decision trees:

http://wiki.apache.org/solr/HierarchicalFaceting#Pivot_Facets


              </script></section>
              <section data-markdown><script type="text/template">
## Relevancy and boosting

Solr computes a *score* for each matching document.

By default, it uses a TF-IDF scoring model *(complicated, see docs)*

              </script></section>
              <section data-markdown><script type="text/template">
## Relevancy and boosting

Each of the criterions in a query can be given a greater importance (or "boosted"). 

E.g we may care a lot more about the author or title than the genre or publisher.

              </script></section>
              <section data-markdown><script type="text/template">
## Relevancy and boosting

Correctly boosting a field or another is extremely error prone.

This makes or breaks a search engine.

              </script></section>
              <section data-markdown><script type="text/template">

## Other query-related goodies

Spatial search:
http://wiki.apache.org/solr/SpatialSearch

More like this: 
http://wiki.apache.org/solr/MoreLikeThis

Spell&nbsp;checker:&nbsp;http://wiki.apache.org/solr/SpellCheckComponent

Suggester:
http://wiki.apache.org/solr/Suggester


              </script></section>
              <section data-markdown><script type="text/template">
# Solr the NoSQL database
              </script></section>
              <section data-markdown><script type="text/template">

## Solr Cloud

* horizontally scalable with an N-shards, M-replicas per shard model
* managed by Zookeeper
* has a transaction-log *(not enabled by default !??)*
* real-time get, near-real-time search

              </script></section>
              <section data-markdown><script type="text/template">
## Sharding

* Index is split into a number of shards
* Each shard has a number of replicas
* A query can hit any shard and it will get routed properly 

Recommendation about the number of shards: better too many than too few. 

              </script></section>
              <section data-markdown><script type="text/template">
## Sharding

Starting with Solr 4.4, shards can be split in two at runtime.

Since, generally, if a shards needs splitting the all shards need splitting, this results in the doubling of nodes.

Re-balancing not yet supported.

              </script></section>
              <section data-markdown><script type="text/template">

# Other related projects
              </script></section>
              <section data-markdown><script type="text/template">

## Alternatives to Solr

* elasticsearch: http://www.elasticsearch.org/
* Amazon CloudSearch: http://aws.amazon.com/cloudsearch/

              </script></section>
              <section data-markdown><script type="text/template">

## Stuff that's usually used together with Solr

* Apache Tika: http://tika.apache.org/
* Apache Nutch: http://nutch.apache.org/

              </script></section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
